<html>
<head>

<title>Merry Christmas Dood!</title>
<script type="text/javascript">

var WIN_SPRITE_INST, WIN_SPRITE_HEAD_INST;
var WIN_HOME = [-0.0, 0.0, 0];
var WIN_POS = WIN_HOME.slice();
var WIN_VEL = [0, 0, 0];
var WIN_JUMP_TIMER = 0;
var CONE_POS = [0,0];
var CONE_SHOW = false;

var CAM;


function draw_sprite(model, sprite, tex)
{
    g.web.assets['mesh/plane'].using_shader('sprite')
                         .with_attribute({name:'a_position', buffer: 'positions', components: 3})
                         .with_attribute({name:'a_tex_coord', buffer: 'texture_coords', components: 2})
                         .set_uniform('u_sprite_sheet').texture(tex)
                         .with_camera(CAM)
                         .set_uniform('u_model').mat4(model)
                         .set_uniform('u_origin_size').vec4(sprite.origin().concat(sprite.size()))
                         .draw_tri_strip();
}

function on_load()
{

g.web.canvas(document.getElementsByTagName('canvas')[0], {fixed_size: false});

g.initialize(function ()
{
    g.is_running = true;

    g.web.gfx.shader.create('sprite', SRC_SPRITE_VS, SRC_SPRITE_FS);
    g.web.assets['tex/win'] = g.web.gfx.texture.create(document.getElementById('win')).color().clamped().pixelated();
    g.web.assets['tex/cone'] = g.web.gfx.texture.create(document.getElementById('cone')).color().clamped().pixelated();
    g.web.assets['sprite/win'] = g.web.gfx.sprite.create(WIN_SPRITE);

    WIN_SPRITE_INST = new g.web.assets['sprite/win']();
    WIN_SPRITE_HEAD_INST = new g.web.assets['sprite/win']();
    WIN_SPRITE_INST.tag = WIN_SPRITE_INST.tags['wag'];
    WIN_SPRITE_HEAD_INST.tag = WIN_SPRITE_HEAD_INST.tags['wag'];
    WIN_SPRITE_INST.layer = 'back';

    g.web.assets['mesh/plane'] = g.web.gfx.mesh.create({
        positions: [
            -1,-1, 0,
            -1, 1, 0,
             1,-1, 0,
             1, 1, 0,
        ],
        texture_coords: [
            1, 0,
            1, 1,
            0, 0,
            0, 1,
        ]
    });

    CAM = new g.camera.create();

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    return true;
});

g.web.pointer.on_press(function (e) {
  CONE_SHOW = true;
});

g.web.pointer.on_release(function (e) {
  CONE_SHOW = false;
  WIN_SPRITE_HEAD_INST.set('wag');
});

g.web.pointer.on_move(function (e) {
  CONE_POS = [(e.clientX + 24) - g.web.gfx.width() / 2, -(e.clientY - 100) + g.web.gfx.height() / 2, 0];
});

g.web.draw(function (dt)
{
    if (g.is_running == false) { return; }

    // Update
    WIN_SPRITE_INST.tick(dt);

    WIN_VEL = WIN_VEL.add([0,-1000,0].mul(dt));
    WIN_POS = WIN_POS.add(WIN_VEL.mul(dt));
    if (WIN_POS[1] < 0)
    {
      WIN_VEL = [0,0,0];
      WIN_POS[1] = 0;

      if (CONE_SHOW)
      {
        WIN_VEL = [0, 200, 0];
      }

      if (CONE_SHOW && CONE_POS[1] > 100)
      {
        WIN_SPRITE_HEAD_INST.set('hop');
      }
      else
      {
        WIN_SPRITE_HEAD_INST.set('wag');
      }
    }

    // Draw
    function scl(x, y, z)
    {
        return [
            [ x, 0, 0, 0 ],
            [ 0, y, 0, 0 ],
            [ 0, 0, z, 0 ],
            [ 0, 0, 0, 1 ]
        ];
    }

    CAM.orthographic(g.web.gfx.width(), g.web.gfx.height(), 0, 1);
    gl.clearColor(0/255, 179/255, 159/255, 1);
    // gl.clearColor(135/255, 206/255, 235/255, 1);
    // gl.clearColor(231/255, 107/255, 7/255, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    let scale = scl(150, 150, 150);

    WIN_SPRITE_INST.layer = 'back';
    draw_sprite(
      scale.mat_mul([].translate([0,0,0])),
      WIN_SPRITE_INST,
      g.web.assets['tex/win']
    );
    WIN_SPRITE_INST.layer = 'body';
    draw_sprite(
      scale.mat_mul([].translate(WIN_POS.mul(0.5))),
      WIN_SPRITE_INST,
      g.web.assets['tex/win']
    );
    WIN_SPRITE_INST.layer = 'front';
    draw_sprite(
      scale.mat_mul([].translate(WIN_POS)),
      WIN_SPRITE_INST,
      g.web.assets['tex/win']
    );
    WIN_SPRITE_HEAD_INST.layer = 'head';
    draw_sprite(
      scale.mat_mul([].translate(WIN_POS)),
      WIN_SPRITE_HEAD_INST,
      g.web.assets['tex/win']
    );

    if (CONE_SHOW)
    g.web.assets['mesh/plane'].using_shader('sprite')
      .with_attribute({name:'a_position', buffer: 'positions', components: 3})
      .with_attribute({name:'a_tex_coord', buffer: 'texture_coords', components: 2})
      .set_uniform('u_sprite_sheet').texture(g.web.assets['tex/cone'])
      .with_camera(CAM)
      .set_uniform('u_model').mat4(scl(50, 50, 50).mat_mul([].translate(CONE_POS)))
      .set_uniform('u_origin_size').vec4([0, 0, 2, 1])
      .draw_tri_strip();
});

g.start();
}

</script>
</head>

<body class="container-fluid bg-dark" style="margin:0;" onload="on_load()">

<canvas class="col" style="width: 100%; height: 100%"></canvas>

<script type="text/javascript">
  const g = {
    _initalize: function() {},
    _update: function() {},
    is_running: true,

    timer: function(){
      this._last = (new Date()).getTime();
      this._start = (new Date()).getTime();

      this.tick = function()
      {
        var t = (new Date()).getTime();
        var dt = t - this._last;
        this._last = t;
        return dt / 1000;
      };

      this.total = function()
      {
        return (new Date()).getTime() - this._start;
      };
    },

    initialize: function(f) { g._initialize = f; return this; },

    update: function(f) { g._update = f; return this; },

    canvas: function(dom_element) { g._canvas = dom_element; return this; },

    start: function(opts)
    {
      var req_frame = window.requestAnimationFrame       ||
                      window.webkitRequestAnimationFrame ||
                      window.mozRequestAnimationFrame    ||
                      window.oRequestAnimationFrame      ||
                      window.msRequestAnimationFrame;
      var step_timer = new g.timer();

      // if we are a browser, setup socket.io to connect to the server
      // if (g.web)
      // {
      //   g.web._socket = io();
      //   g.web._socket.binaryType = 'arraybuffer';
      //   g.web._socket.on('message', g.web._on_message);

      //   for (var e in g.web._on_event)
      //   {
      //     g.web._socket.on(e, g.web._on_event[e]);
      //   }

      //   g.web.socket = function() { return g.web._socket; }
      //         if (!g.web.gfx._initalize()) { return; }
      //         g.web.snd._initalize();
      // }

      if (!g.web.gfx._initalize()) { return; }
      g.web.snd._initalize();

      // custom initialization
      if (!g._initialize())
      {
        console.error('initialize_func(): returned false.');
        return;
      }

      // update, and render if appropriate
      var frames = 0;
      var time_since_sec = 0;
      var update = function() {
        var dt = step_timer.tick();

        if (g.is_running && (dt > 0 && dt < 1) && isFinite(dt))
        {
          g._update(dt);

          if (g.web)
          {
            g.web._draw(dt);
          }
        }

        if (g.web) { req_frame(update); }

        if (opts && opts.print_fps)
        {
          if (time_since_sec >= 1)
          {
            console.log(frames + ' fps');
            frames = 0;
            time_since_sec = 0;
          }
          time_since_sec += dt;
          frames++;
        }
      };

      if (g.web) { req_frame(update); }
    },

    voxel: {
      create: function(voxel_data)
      {
        // process data into uniform type here.
        var palette = null;
        var locations = [];
        const RGBA = voxel_data.RGBA.slice();

        // grab the palette if it exists
        if (voxel_data.palette)
        {
          palette = new Array(voxel_data.palette.length / 4);
          for (var pi = 0; pi < voxel_data.palette.length; pi += 4)
          {
            palette[pi >> 2] = [voxel_data.palette[pi + 0] / 255, voxel_data.palette[pi + 1] / 255, voxel_data.palette[pi + 2] / 255];//, palette[pi].a / 255];
          }
        }

        // convert to uniform data storage
        if (voxel_data.SIZE)
        {
          var cells = new Array(voxel_data.SIZE.x);
          for (var xi = voxel_data.SIZE.x; xi--;)
          {
            cells[xi] = new Array(voxel_data.SIZE.z);
            for (var yi = voxel_data.SIZE.z; yi--;)
            {
              cells[xi][yi] = new Array(voxel_data.SIZE.y);
              cells[xi][yi].fill(0);
            }
          }

          for (var vi = voxel_data.XYZI.length; vi--;)
          {
            const set = voxel_data.XYZI[vi];
            cells[set.x][set.z][set.y] = set.c - 1;
          }

          if (voxel_data.RGBA && typeof(voxel_data.RGBA[0]) == 'object')
          {
            palette = voxel_data.RGBA;
            for (var pi = palette.length; pi--;)
            {
              if (!palette[pi]) { continue; }
              palette[pi] = [palette[pi].r / 255, palette[pi].g / 255, palette[pi].b / 255];//, palette[pi].a / 255];
            }
          }

          voxel_data = {
            width: voxel_data.SIZE.x,
            height: voxel_data.SIZE.z,
            depth: voxel_data.SIZE.y,
            scale: voxel_data.scale || 1,
            palette: palette,
            cells: cells
          };
        }

        const w = voxel_data.width;
        const h = voxel_data.height;
        const d = voxel_data.depth;
        const s = voxel_data.scale || 1;
        var cells = voxel_data.cells;
        var center_of_mass = [0, 0, 0];

        return {
          width: w,
          height: h,
          depth: d,
          scale: s,
          palette: palette,
          cells: cells,
          center_of_mass: function(force)
          {
            if (force || center_of_mass.sum() == 0)
            {
              center_of_mass = [0, 0, 0];
              var cell_count = 0;
              for (var x = w; x--;)
              for (var y = h; y--;)
              for (var z = d; z--;)
              {
                if (cells[x][y][z] > 0)
                {
                  center_of_mass = center_of_mass.add([x, y, z]);
                  cell_count++;
                }
              }

              center_of_mass = center_of_mass.mul(s / cell_count);
            }

            return center_of_mass;
          },
          intersection: function(pos, dir)
          {
            pos = pos.mul(1/s);
            dir = dir.mul(1/s);
            var fp = pos.floor(), cp = pos.ceil();

            let itrs = Math.ceil(dir.len()) * 5;
            for (var p = 0; p < itrs; p++)
            {
              const pd = pos.add(dir.mul(p / itrs));
              const pd_f = pd.floor();
              const pd_c = pd.ceil();

              if (pd_f[0] < 0 || pd_f[0] >= w) { return false; }
              if (pd_f[1] < 0 || pd_f[1] >= h) { return false; }
              if (pd_f[2] < 0 || pd_f[2] >= d) { return false; }

              if (cells[pd_f[0]][pd_f[1]][pd_f[2]] > 0)
              {
                var norm = fp.sub(pd_f);
                if (norm.dot(norm) > 0) { norm = norm.norm(); }

                var pen = [0, 0, 0];

                for (var i = 0; i < 3; i++)
                {
                  if (dir[i] >= 0) { pen[i] = pd[i] - pd_f[i]; }
                  else             { pen[i] = pd[i] - pd_c[i]; }
                }

                return {
                  point: pd,
                  normal: norm,
                  penetration: pen
                };
              }
            }

            return false;
          },
          sample: function(pos)
          {
            pos = pos.mul(1/s);
            var fp = pos.floor();

            if (fp[0] < 0 || fp[0] >= w) { return undefined; }
            if (fp[1] < 0 || fp[1] >= h) { return undefined; }
            if (fp[2] < 0 || fp[2] >= d) { return undefined; }

            return {
              point: fp.mul(s),
              cell: cells[fp[0]][fp[1]][fp[2]]
            }
          },
          each_voxel: function(cb)
          {
            for (var x = 0; x < w; x++)
            for (var y = 0; y < h; y++)
            for (var z = 0; z < d; z++)
            {
              if (cells[x][y][z])
              {
                if (cb(x, y, z)) { return; }
              }
            }
          },
          downsample: function(factor)
          {
            var vox_data = {
              SIZE: {
                x: w / factor,
                y: d / factor,
                z: h / factor,
              },
              XYZI: [],
              RGBA: RGBA,
              scale: voxel_data.scale * factor
              // palette: palette
            };

            for (var ds_x = 0; ds_x < vox_data.SIZE.x; ds_x++)
            for (var ds_y = 0; ds_y < vox_data.SIZE.z; ds_y++)
            for (var ds_z = 0; ds_z < vox_data.SIZE.y; ds_z++)
            {

              // find the mode of this downsampled block
              var filled = 0;
              var empty = 0;
              var last_id = 0;
              for (var x = ds_x * factor; x < (ds_x + 1) * factor; x++)
              for (var y = ds_y * factor; y < (ds_y + 1) * factor; y++)
              for (var z = ds_z * factor; z < (ds_z + 1) * factor; z++)
              {
                const id = cells[x][y][z];
                if (id <= 0) { empty += 1; }
                else
                {
                  filled += 1;
                  last_id = id;
                }
              }

              var mode = 0;
              if (filled > empty / 2)
              {
                mode = last_id;
              }

              if (mode)
              vox_data.XYZI.push({
                x: ds_x,
                y: ds_z,
                z: ds_y,
                c: mode + 1
              });
            }

            return g.voxel.create(vox_data);
          }
        };
      }
    },

    animation: {
      create: function(json)
      {
        var frames = [];
        var tags = {};

        for_each(json.meta.frameTags, (frame_tag) => {
          tags[frame_tag.name] = [];
          switch (frame_tag.direction)
          {
            case 'forward':
              for (var i = frame_tag.from; i <= frame_tag.to; ++i)
              {
                tags[frame_tag.name].push(i);
              }
              break;
            case 'pingpong':
              for (var i = frame_tag.from; i <= frame_tag.to; ++i)
              {
                tags[frame_tag.name].push(i);
              }
              for (var i = frame_tag.to; i >= frame_tag.from; --i)
              {
                tags[frame_tag.name].push(i);
              }
              break;
          }

          tag = tags[frame_tag.name];
        });

        for_each(json.frames, (frame_meta) => {
          const frame = frame_meta.frame;
          frames.push({
            asset: frame_meta.asset,
            sec: frame_meta.duration / 1000
          });
        });

        return function() {
          this.frame_idx = 0;
          this.frame_duration = frames[0].sec;
          this.paused = false;
          this.speed = 1;
          this.tag = tag;
          this.tags = tags;
          this.queue = [];

          this.current_frame = function()
          {
            return frames[this.tag[this.frame_idx]];
          }

          this.pause = function(pause) { this.paused = pause; }

          this.tick = function(dt)
          {
            dt *= this.speed;

            if(!this.paused)
            while (dt > 0)
            {
              const prev_dur = this.frame_duration;
              this.frame_duration -= dt;

              if (this.frame_duration <= 0)
              {
                this.frame_idx++;
                if (this.frame_idx >= this.tag.length)
                {
                  if (this.queue.length > 0)
                  {
                    this.tag = this.queue.pop();
                  }

                  this.frame_idx = 0;
                }
                this.frame_duration = this.current_frame().sec;
              }

              dt -= prev_dur;
            }
          };

          this.set = function(tag)
          {
            this.frame_idx = 0;
            this.tag = this.tags[tag];
          }
        };
      }
    },

    camera: {
      create: function()
      {
        var _q = [0,0,0,1];
        var _view = [].I(4);
        var _proj = [].I(4);
        var _pos = [0,0,0];
        var _forward = [0,0,-1];
        var _up = [0,1,0];
        var _left = [-1,0,0];
        var is_listener = true;

        var cam = {
          look_at: function(position, subject, up)
          {
            if (position && subject && up)
            {
              _pos = position;
              _forward = position.sub(subject).norm();
              _up = up.norm();
              _view = [].view(_pos, _forward, _up);
              _left = _q.quat_rotate_vector([-1, 0, 0]);
            }

            return _view;
          },
          orientation: function(q)
          {
            if (q) { _q = q; }

            _up = _q.quat_rotate_vector([0, 1, 0]);
            _forward = _q.quat_rotate_vector([0, 0, -1]);
            _left = _q.quat_rotate_vector([-1, 0, 0]);

            return _q;
          },
          tilt: function(d_yaw, d_pitch, d_roll)
          {
            d_yaw = d_yaw || 0;
            d_pitch = d_pitch || 0;
            d_roll = d_roll || 0;

            const dqx = [].quat_rotation([1, 0, 0], d_yaw);
            const dqy = [].quat_rotation([0, 1, 0], d_pitch);
            const dqz = [].quat_rotation([0, 0, 1], d_roll);
            const dq = dqx.quat_mul(dqy).quat_mul(dqz);
            _q = _q.quat_mul(dq);

            _up = _q.quat_rotate_vector([0, 1, 0]);
            _forward = _q.quat_rotate_vector([0, 0, -1]);
            _left = _q.quat_rotate_vector([-1, 0, 0]);

            this.view(_pos, _forward, _up);
          },
          position: function(p)
          {
            if (p)
            {
              _pos = p;
              this.view(_pos, _forward, _up);
            }

            return _pos;
          },
          up: function(u)
          {
            if (u)
            {
              _up = u;
              this.view(_pos, _forward, _up);
            }

            return _up;
          },
          left: function()
          {
            return _left;
          },
          forward: function(f)
          {
            if (f)
            {
              _forward = f;
              this.view(_pos, _forward, _up);
            }

            return _forward;
          },
          projection: function() { return _proj; },
          perspective: function(fov, near, far)
          {
            fov = fov || Math.PI / 2;
            near = near || 0.1;
            far = far || 1000;

            _proj = [].perspective(fov, g.web.gfx.aspect(), near, far);

            return this;
          },
          orthographic: function(width, height, near, far)
          {
            const a = g.web.gfx.aspect();
            near = near || 0.1;
            far = far || 500;
            _proj = [].orthographic(width/2, -width/2, height/2, -height/2, near, far);

            return this;
          }
        };

        cam.view = (position, forward, up) => {
          if (position && forward && up)
          {
            _pos = position;
            _forward = forward.norm();
            _up = up.norm();
            _left = _up.cross(_forward);
            _up = _forward.cross(_left);
            _view = [].view(_pos, _forward, _up);
            // _left = _q.quat_rotate_vector([-1, 0, 0]);

            if (is_listener && g.web && g.web._audio_ctx) { g.web.snd.listener.from_camera(cam); }
          }

          return _view;
        };

        return cam;
      },
      fps: function(opts)
      {
        var cam = g.camera.create();

        cam.mass = 1.0;
        cam.force = 1.0;
        cam.friction = 1.0;
        cam.forces = [];
        cam.max_pitch = Math.PI / 2;
        cam.min_pitch = -Math.PI / 2;

        var pitch = 0;
        var yaw = 0;
        var velocity = [0, 0, 0];
        var last_collisions = [];
        var coll_offsets = [];
        var coll_dirs = [];

        if (opts && opts.collision_rep)
        {

        }
        else
        {
          // default cube collision rep
          for (var i = -1; i <= 1; i++)
          {
            if (0 == i) { continue; }
            coll_dirs.push([i, 0, 0].mul(0.125));
            coll_dirs.push([0, i, 0].mul(1));
            coll_dirs.push([0, 0, i].mul(0.125));
          }

          for (var x = -1; x <= 1; x++)
          for (var y = -1; y <= 1; y++)
          for (var z = -1; z <= 1; z++)
          {
            if (x + y + z == 0) { continue; }
            coll_offsets.push([x, y, z].mul(0.25));
          }
        }

        cam.walk = {
          forward: (dt)=> {
            if (cam.is_airborn()) { dt *= 0.25; }
            var accel = cam.forward().mul(-dt * cam.force / cam.mass);
            velocity = velocity.add(accel);
          },
          backward: (dt)=> {
            if (cam.is_airborn()) { dt *= 0.25; }
            var accel = cam.forward().mul(dt * cam.force / cam.mass);
            velocity = velocity.add(accel);
          },
          left: (dt)=> {
            if (cam.is_airborn()) { dt *= 0.25; }
            var accel = cam.left().mul(dt * cam.force / cam.mass);
            velocity = velocity.add(accel);
          },
          right: (dt)=> {
            if (cam.is_airborn()) { dt *= 0.25; }
            var accel = cam.left().mul(-dt * cam.force / cam.mass);
            velocity = velocity.add(accel);
          }
        };

        cam.force = (force, dt) => {
          var accel = force.mul(dt / cam.mass);
          velocity = velocity.add(accel);
        };

        cam.velocity = (vel) => {
          if (vel) { velocity = vel; }
          else { return velocity; }
        };

        cam.tilt = (d_pitch, d_yaw) => {
          const new_pitch = pitch + d_pitch;

          if (new_pitch > cam.min_pitch && new_pitch < cam.max_pitch)
          {
            pitch = new_pitch;
          }

          yaw += d_yaw;

          const pos = cam.position();

          const qx = [].quat_rotation([1, 0, 0], pitch);
          const qy = [].quat_rotation([0, 1, 0], yaw);
          const q = cam._q = qy.quat_mul(qx)

          const up = q.quat_rotate_vector([0, 1, 0]);
          const forward = q.quat_rotate_vector([0, 0, -1]);
          // cam._left = cam._q.quat_rotate_vector([-1, 0, 0]));

          cam.view(pos, forward, up);
        };

        cam.pitch = (p) => {
          if (p)
          {
            pitch = p;

            const qx = [].quat_rotation([1, 0, 0], pitch);
            const qy = [].quat_rotation([0, 1, 0], yaw);
            const q = qx.quat_mul(qy);

            let up = qx.quat_rotate_vector([0, 1, 0]);
            up = qy.quat_rotate_vector(up);

            let forward = qx.quat_rotate_vector([0, 0, 1]);
            forward = qy.quat_rotate_vector(forward);

            cam.view(cam.position(), forward, up);
          }
          return pitch;
        };

        cam.yaw = (y) => {
          if (y)
          {
            yaw = y;

            const qx = [].quat_rotation([1, 0, 0], pitch);
            const qy = [].quat_rotation([0, 1, 0], yaw);
            const q = qx.quat_mul(qy)

            const up = q.quat_rotate_vector([0, 1, 0]);
            const forward = q.quat_rotate_vector([0, 0, 1]);
            cam.forward(forward);
          }
          return yaw;
        };

        cam.last_collisions = () => { return last_collisions; }

        cam.is_airborn = () => {
          var sum = 0;
          for (var i = 0; i < last_collisions.length; i++)
          {
            sum += last_collisions[i].normal.dot([0, 1, 0])
          }
          return sum < 0.0001;
        }

        cam.update = (dt)=> {
          var new_vel = [0, 0, 0];

          if (opts.dynamics)
          {
            new_vel = opts.dynamics(cam, dt);
          }
          else
          { // default dynamics
            var net_force = [0, 0, 0];

            for (var i = 0; i < cam.forces.length; i++)
            {
              net_force = net_force.add(cam.forces[i]);
            }

            const net_accel = net_force.mul(dt / cam.mass);
            var new_vel = velocity.add(net_accel);
          }

          last_collisions = [];

          if (opts && opts.collides)
          for (var i = coll_offsets.length; i--;)
          for (var j = coll_dirs.length; j--;)
          {
            var dir = coll_dirs[j];

            const new_vel_dt = new_vel.mul(dt);
            if (dir.dot(new_vel_dt) > 0)
            {
              dir = dir.add(new_vel_dt);
            }

            const collision = opts.collides(
              coll_offsets[i].add(cam.position()),
              dir
            );

            if (collision)
            {
              if (collision.normal.dot(velocity) - 0.001 >= 0) { continue; }

              last_collisions.push(collision);

              if (opts.on_collision) { opts.on_collision(cam, collision); }
              else
              {
                const cancled = new_vel.mul(collision.normal.abs());
                new_vel = new_vel.sub(cancled);
              }
            }
          }

          if (last_collisions.length > 0)
          {
            new_vel = new_vel.add(new_vel.mul(-cam.friction * dt));
          }

          if (!isFinite(new_vel[0]))
          {
            console.log('why');
          }

          velocity = new_vel;
          const pos = cam.position().add(velocity.mul(dt));

          const qx = [].quat_rotation([1, 0, 0], pitch);
          const qy = [].quat_rotation([0, 1, 0], yaw);
          const q = cam._q = qy.quat_mul(qx)

          const up = q.quat_rotate_vector([0, 1, 0]);
          const forward = q.quat_rotate_vector([0, 0, -1]);
          // cam._left = cam._q.quat_rotate_vector([-1, 0, 0]));

          cam.view(pos, forward, up);

        };

        return cam;
      }
    },
  };

  Array.prototype.within_sphere = function(sphere, position_key, item_cb)
  {
    if (typeof(position_key) == 'string')
    {
      const key_str = position_key;
      position_key = function(item) { return item[key_str]; }
    }

    for (var i = 0; i < this.length; ++i)
    {
      const pos = position_key(this[i]);
      if (pos.sub(sphere).len() <= sphere[3]) { return item_cb(i); }
    }
  }

  Array.prototype.is_matrix = function()
  {
    return this[0] && this[0].constructor === Array;
  }

  Array.prototype.new_matrix = function(rows, cols)
  {
    var M = new Array(rows);
    for (var r = rows; r--;)
    {
      M[r] = new Array(cols);
      for (var c = cols; c--;) { M[r][c] = 0; }
    }
    return M;
  };

  Array.prototype.sum = function()
  {
    var sum = 0;
    for (var i = this.length; i--;) { sum += this[i]; }
    return sum;
  }

  Array.prototype.add = function(v)
  {
    var r = new Array(this.length);

    if (typeof v === 'number')        { for (var i = this.length; i--;) r[i] = this[i] + v; }
    else if (v.constructor === Array) { for (var i = this.length; i--;) r[i] = this[i] + v[i]; }

    return r;
  };

  Array.prototype.sub = function(v)
  {
    var r = new Array(this.length);

    if (typeof v === 'number')        { for (var i = this.length; i--;) r[i] = this[i] - v; }
    else if (v.constructor === Array) { for (var i = this.length; i--;) r[i] = this[i] - v[i]; }

    return r;
  };

  Array.prototype.floor = function()
  {
    var r = new Array(this.length);

    for (var i = this.length; i--;) r[i] = Math.floor(this[i]);

    return r;
  };

  Array.prototype.ceil = function()
  {
    var r = new Array(this.length);

    for (var i = this.length; i--;) r[i] = Math.ceil(this[i]);

    return r;
  };

  Array.prototype.abs = function()
  {
    var r = new Array(this.length);

    for (var i = this.length; i--;) r[i] = Math.abs(this[i]);

    return r;
  };

  Array.prototype.mul = function(v)
  {
    var w = new Array(this.length);

    if (typeof v === 'number')
    {
      if (this.is_matrix())
      {
        const dims = this.mat_dims();
        for (var r = dims[0]; r--;)
        {
          w[r] = new Array(dims[1]);
          for (var c = dims[1]; c--;)
          {
            w[r][c] = this[r][c] * v;
          }
        }
      }
      else
      {
        for (var i = this.length; i--;) w[i] = this[i] * v;
      }
    }
    else if (v.constructor === Array && typeof v[0] === 'number') { for (var i = this.length; i--;) w[i] = this[i] * v[i]; }

    return w;
  };

  Array.prototype.eq = function(v)
  {
    for (var i = 0; i < this.length; i++)
    {
      if (this[i] !== v[i]) { return false; }
    }

    return true;
  };

  Array.prototype.pow = function(ex)
  {
    var w = new Array(this.length);

    if (typeof ex === 'number')
    {
      if (this.is_matrix())
      {
        const dims = this.mat_dims();
        for (var r = dims[0]; r--;)
        {
          w[r] = new Array(dims[1]);
          for (var c = dims[1]; c--;)
          {
            w[r][c] = Math.pow(this[r][c], ex);
          }
        }
      }
      else
      {
        for (var i = this.length; i--;) w[i] = Math.pow(this[i], ex);
      }
    }
    else if (v.constructor === Array && typeof ex[0] === 'number') { for (var i = this.length; i--;) w[i] = Math.pow(this[i], ex[i]); }

    return w;
  };

  Array.prototype.div = function(v)
  {
    var r = new Array(this.length);

    if (typeof v === 'number')        { for (var i = this.length; i--;) r[i] = this[i] / v; }
    else if (v.constructor === Array) { for (var i = this.length; i--;) r[i] = this[i] / v[i]; }

    return r;
  };

  Array.prototype.lerp = function(v, p)
  {
    var r = new Array(this.length);
    for (var i = 0; i < r.length; i++) { r[i] = this[i] * (1-p) + v[i] * p; }
    return r;
  };

  Array.prototype.len = function()
  {
    if (typeof this[0] !== 'number') { return NaN; }

    return Math.sqrt(this.dot(this));
  };

  Array.prototype.dist = function(v)
  {
    return this.sub(v).len();
  }

  Array.prototype.norm = function()
  {
    if (typeof this[0] !== 'number') { return null; }

    return this.div(this.len());
  }

  Array.prototype.mat_dims = function()
  {
    return [ this.length, this[0].length ];
  };

  Array.prototype.intersects_sphere = function(origin, radius)
  {
    const l = origin;
    const s = this.dot(l);
    const l_2 = l.dot(l);
    const r_2 = radius * radius;
    var t = 0;

    if (s < 0 && l_2 > r_2) { return false; }

    const m_2 = l_2 - s * s;

    if (m_2 > r_2) { return false; }

    const q = Math.sqrt(r_2 - m_2);

    if (r_2 - m_2)
    {
      t = s - q;
    }
    else
    {
      t = s + q;
    }

    return this.mul(t);
  };

  Array.prototype.mat_mul = function(m)
  {
    var M = this.matrix();
    var N = m.matrix();

    const m0_dims = M.mat_dims();
    const m1_dims = N.mat_dims();

    var O = this.new_matrix(m0_dims[0], m1_dims[1]);

    var inner = m0_dims[1];
    for (var r = m0_dims[0]; r--;)
    for (var c = m1_dims[1]; c--;)
    {
      O[r][c] = 0;
      for (var i = inner; i--;) { O[r][c] += M[r][i] * N[i][c]; }
    }

    return O;
  };

  Array.prototype.swap_rows = function(row_i, row_j)
  {
    const tmp = this[i];
    this[i] = this[j];
    this[j] = tmp;
    return this;
  };

  Array.prototype.augment = function()
  {
    const dims = this.mat_dims();
    const R = dims[0], C = dims[1];
      const Mc = C * 2;
      var M = this.new_matrix(R, Mc);

      for (var r = R; r--;)
      {
          // form the identity on the right hand side
          M[r][r + C] = 1.0;

          for (var c = C; c--;)
          {
              M[r][c] = this[r][c];
          }
      }

      return M;
  };

  Array.prototype.rref = function()
  {
    var M = this.matrix();
    const dims = M.mat_dims();
    const R = dims[0], C = dims[1];
    var piv_c = 0;

      // compute upper diagonal
      for (var r = 0; r < R; r++)
      {
          // Check if the piv column of row r is zero. If it is, lets
          // try to find a row below that has a non-zero column
          if (M[r][piv_c] == 0)
          {
              var swap_ri = -1;
              for (var ri = r + 1; ri < R; ri++)
              {
                  if (M[ri][piv_c] != 0)
                  {
                      swap_ri = ri;
                      break;
                  }
              }

              if (swap_ri > -1) { M.swap_rows(swap_ri, r); }
          }

          { // next row, scale so leading coefficient is 1
              const d = 1 / M[r][piv_c];

              // scale row
              for (var c = piv_c; c < C; c++) { M[r][c] *= d; }
          }


          for (var ri = 0; ri < R; ri++)
          {
              // skip zero elements and skip row r
              if (M[ri][piv_c] == 0 || ri == r) { continue; }

              const d = M[ri][piv_c];

              // scale row then subtract the row above to zero out
              // other elements in this column
              for (var c = piv_c; c < C; c++)
              {
                  M[ri][c] -= d * M[r][c];
              }
          }

          ++piv_c;
      }

    return M;
  };

  Array.prototype.inverse = function()
  {
    const dims = this.mat_dims();
    const R = dims[0], C = dims[1];
    const _rref = this.augment().rref();

    var M = new Array(R);

    for (var r = R; r--;)
    {
      var s = _rref[r].slice(C, 2 * C);
      M[r] = s;
    }

    return M;
  };

  Array.prototype.flatten = function()
  {
    var v = [];

    if (typeof(this[0]) === 'number') { v = this; }
    else
    {
      for (var i = 0; i < this.length; ++i)
      {
        v = v.concat(this[i].flatten());
      }
    }

    return v;
  };

  Array.prototype.as_Float32Array_bin = function() {
    const flat = this.flatten();
    var buf = new ArrayBuffer(flat.length * 4);
    var a = new Float32Array(buf);

    for (var i = flat.length; i--;)
    {
      a[i] = flat[i];
    }

    return buf;
  };

  Array.prototype.as_Float32Array = function() {
    return new Float32Array(this.flatten());
  };

  Array.prototype.as_Int32Array = function(first_argument) {
    return new Int32Array(this.flatten());
  };

  Array.prototype.as_Int16Array = function(first_argument) {
    return new Int16Array(this.flatten());
  };

  Array.prototype.transpose = function()
  {
    const dims = this.mat_dims();
    var M = this.new_matrix(dims[1], dims[0]);

    for (var r = dims[0]; r--;)
    for (var c = dims[1]; c--;)
    {
      M[c][r] = this[r][c];
    }

    return M;
  };

  Array.prototype.matrix = function()
  {
    if (this[0].constructor === Array) { return this; }
    else { return [this].transpose(); }
  };

  Array.prototype.random_unit = function()
  {
    return [Math.random(), Math.random(), Math.random()].sub([0.5, 0.5, 0.5]).norm();
  }

  Array.prototype.I = function(dim)
  {
    var M = this.new_matrix(dim, dim);

    for (var r = dim; r--;)
    for (var c = dim; c--;)
    {
      M[c][r] = r == c ? 1 : 0;
    }

    return M;
  };

  Array.prototype.dot = function(v)
  {
    var s = 0;
    for (var i = this.length; i--;) s += this[i] * v[i];
    return s;
  }

  Array.prototype.cross = function(v)
  {
    return [
      this[1] * v[2] - this[2] * v[1],
      this[2] * v[0] - this[0] * v[2],
      this[0] * v[1] - this[1] * v[0]
    ];
  }

  Array.prototype.mat_scale = function(s)
  {
    return [
      [    s[0], 0,    0,    0    ],
      [    0,    s[1], 0,    0    ],
      [    0,    0,    s[2], 0    ],
      [    0,    0,    0,    1.   ]
    ];
  };

  Array.prototype.translate = function(t)
  {
    return [
      [    1,    0,    0,    0    ],
      [    0,    1,    0,    0    ],
      [    0,    0,    1,    0    ],
      [  t[0], t[1], t[2],   1.   ]
    ];
  };

  Array.prototype.perspective = function(fov, aspect, n, f)
  {
    const a = Math.tan(Math.PI * 0.5 - 0.5 * fov);
    const fsn = f - n;
    const fpn = f + n;
    const ftn = f * n;

    return [
           [  a/aspect,         0,          0,         0 ],
           [         0,         a,          0,         0 ],
           [         0,         0,   -fpn/fsn,        -1 ],
           [         0,         0, -2*ftn/fsn,         0 ]
    ];

    // return [
    //        [  a/aspect,         0,          0,         0 ],
    //        [         0,         a,          0,         0 ],
    //        [         0,         0,   -fpn/fsn,        -1 ],
    //        [         0,         0, -2*ftn/fsn,         1 ]
    // ];
  };

  Array.prototype.orthographic = function(r, l, t, b, n, f)
  {
    const rml = r - l;
    const rpl = r + l;
    const tmb = t - b;
    const tpb = t + b;
    const fmn = f - n;
    const fpn = f + n;

    // return [
    //        [  2/rml,         0,          0, -rpl/rml ],
    //        [      0,     2/tmb,          0, -tpb/tmb ],
    //        [      0,         0,     -2/fmn, -fpn/fmn ],
    //        [      0,         0,          0,        1 ]
    // ];

    return [
      [2/rml,     0,      0,     0],
      [    0, 2/tmb,      0,     0],
      [    0,     0, -2/fmn,     0],
      [    0,     0,      0,     1],
    ];
  };

  Array.prototype.view = function(position, forward, up)
  {
    const r = forward.cross(up).mul(1);
    const u = up;
    const t = r.cross(forward);
    const f = forward;
    const p = position;

    var ori = [
      [ r[0], t[0], f[0], 0 ],
      [ r[1], t[1], f[1], 0 ],
      [ r[2], t[2], f[2], 0 ],
      [    0,    0,    0, 1 ]
    ];

    var trans = [
      [     1,     0,     0,    0 ],
      [     0,     1,     0,    0 ],
      [     0,     0,     1,    0 ],
      [ -p[0], -p[1], -p[2],    1 ]
    ];

    //return ori;
    return trans.mat_mul(ori);
    //return ori.mat_mul(trans);
  };

  Array.prototype.rotation = function(axis, angle)
  {
    const a = axis;
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const omc = 1 - c;

    return [
      [c+a[0]*a[0]*omc,      a[1]*a[0]*omc+a[2]*s, a[2]*a[0]*omc-a[1]*s, 0],
      [a[0]*a[1]*omc-a[2]*s, c+a[1]*a[1]*omc,      a[2]*a[1]*omc+a[0]*s, 0],
      [a[0]*a[2]*omc+a[1]*s, a[1]*a[2]*omc-a[0]*s, c+a[2]*a[2]*omc,      0],
      [                   0,                    0,                    0, 1]
    ];
  };


  Array.prototype.scale = function(s)
  {
      var m;
      if (typeof(s) === 'number')
      {
          m = [].I(4).mul(s);
          m[3][3] = 1;
      }
      else if (s instanceof Array)
      {
          m = [].I(s.length);
          for (var i = s.length; i--;)
          {
              m[i][i] = s[i];
          }
      }

    return m;
  }


  Array.prototype.quat_rotation = function(axis, angle)
  {
    var a_2 = angle / 2;
    var a = Math.sin(a_2);

    const _axis = axis.mul(a);

    return _axis.concat(Math.cos(a_2));
  };


  Array.prototype.quat_rotate_vector = function(v)
  {
    var q_xyz = this.slice(0, 3);

    var t = q_xyz.cross(v);
    t = t.mul(2);

    var u = q_xyz.cross(t);
    t = t.mul(this[3]);

    return v.add(t).add(u);
  };


  Array.prototype.quat_to_matrix = function()
  {
    var v = this;
    var a = v[3], b = v[0], c = v[1], d = v[2];
    var a2 = a * a, b2 = b * b, c2 = c * c, d2 = d * d;

    return [
        [ a2 + b2 - c2 - d2, 2*b*c - 2*a*d  , 2*b*d + 2*a*c  , 0],
        [ 2*b*c + 2*a*d  , a2 - b2 + c2 - d2, 2*c*d - 2*a*b  , 0],
        [ 2*b*d - 2*a*c  , 2*c*d + 2*a*b  , a2 - b2 - c2 + d2, 0],
        [ 0                , 0                , 0                , 1],
    ];
  };

  Array.prototype.quat_conjugate = function()
  {
    return this.mul([-1, -1, -1, 1]);
  }

  Array.prototype.quat_inverse = function()
  {
    const mag_2 = this.dot(this);
    return this.quat_conjugate().mul(1/mag_2);
  }

  Array.prototype.quat_mul = function(q)
  {
    // var q0 = this;
    // var q1 = q;

    // var t3 = q0.slice(0, 3);
    // var o3 = q1.slice(0, 3);

    // var r = t3.cross(o3);
    // var w = t3.mul(q1[3]);
    // r = r.add(w);
    // w = o3.mul(q0[3]);
    // r = r.add(w);

    // return r.concat(q0[3] * q1[3] - t3.dot(o3));
    return [
        this[3] * q[0] + this[0] * q[3] + this[1] * q[2] - this[2] * q[1],  // i
        this[3] * q[1] - this[0] * q[2] + this[1] * q[3] + this[2] * q[0],  // j
        this[3] * q[2] + this[0] * q[1] - this[1] * q[0] + this[2] * q[3],   // k
        this[3] * q[3] - this[0] * q[0] - this[1] * q[1] - this[2] * q[2],  // 1
    ];
  };

  String.prototype.format = function(value_list)
  {
    const parts = this.split('{}');
    var out = '';
    var vi = 0;

    for (var i = 0; i < parts.length; i++)
    {
      out += parts[i];
      if (vi < value_list.length) { out += value_list[vi++]; }
    }

    return out;
  }

  function for_each(obj, cb)
  {
    if (!obj) { return obj; }
    if (obj.constructor === Array)
    {
      return obj.for_each(cb);
    }
    else
    {
      for (var k in obj)
      {
        if (!obj.hasOwnProperty(k)) { continue; }
        cb(obj[k], k, this);
      }

      return obj;
    }
  }

  Array.prototype.for_each = function(cb)
  {
    for (var i = 0; i < this.length; ++i)
    {
      cb(this[i], i, this);
    }

    return this;
  };

  Array.prototype.accumulate = function(dst_key, src_key, scale)
  {
    scale = scale || 1;

    for (var i = this.length; i--;)
    {
      this[i][dst_key] = this[i][dst_key].add(this[i][src_key].mul(scale));
    }
  };

  Array.prototype.pick = function()
  {
    return this[Math.floor(Math.random() * this.length)];
  };


  Array.prototype.timed_queue = function() {
    this.last_idx = function() { return this.length - 1 < 0 ? 0 : this.length - 1; },
    this.peek = function()
    {
      if (this.empty()) { return null; }
      return this[this.last_idx()].value;
    };

    this.empty = function() { return this.length == 0; };

    this.push = function(val, time)
    {
      const v = val.value || val;
      const t = val.time || time;
      this.unshift({ value: v, time: t });
    };

    this.update = function(dt)
    {
            if (this.empty()) { return this; }

      this[this.last_idx()].time -= dt;
            const time = this[this.last_idx()].time;

      if (time <= 0) { this.pop(); }
    }

    return this;
  };

  Math.ray = function(ray)
  {
    return {
      intersects: {
        sphere: function(position, radius)
        {
          const l = position.sub(ray.position);
          const s = ray.direction.dot(l);
          const l_2 = l.dot(l);
          const r_2 = radius * radius;
          var t = 0;

          if (s < 0 && l_2 > r_2) { return false; }

          const m_2 = l_2 - s * s;

          if (m_2 > r_2) { return false; }

          const q = Math.sqrt(r_2 - m_2);

          if (r_2 - m_2)
          {
            t = s - q;
          }
          else
          {
            t = s + q;
          }

          return t;
        }
      }
    };
  };

  Math.random.uni = function()
  {
    return 2 * Math.random() - 1;
  }

  Math.random.unit_vector = function(i)
  {
    i = i || Math.floor(Math.random() * 1000);

    // compute random rotation axis look up table
    if (!this._uv_lut)
    {
      this._uv_lut = [];
      for(var _ = 1000; _--;)
      {
          this._uv_lut.push([].random_unit());
      }
    }

    return this._uv_lut[i];
  }

  Math.model_matrix = function(obj)
  {
    var M = [].I(4);

    if ('scale' in obj)
    {
      M = M.mat_mul([].scale(obj.scale))
    }
    if ('q' in obj)
    {
      M = M.mat_mul(obj.q.quat_inverse().quat_to_matrix());
    }
    if ('position' in obj)
    {
      M = M.mat_mul([].translate(obj.position));
    }

    return M;
  };

  try
  {
    module.exports = g;
    module.exports.for_each = for_each;
  }
  catch(e)
  {
    g.for_each = for_each;
    console.log('Not a node.js module');
  }

</script>
<script type="text/javascript">
  g.web = {
    _draw: function() {},
    _on_message: function() {},
    _on_event: {},
    _canvas: null,
    _audio_ctx: null,

    gfx: {
      _initalize: function()
      {
        with (g.web)
        {
          if (_canvas == null)
          {
            console.error('Canvas element has not been set, WebGL cannot initialize');
            return false;
          }

          const gl = _canvas.getContext('webgl');
          const depth_ext = gl.getExtension('WEBGL_depth_texture');
          if (!depth_ext) {
            return alert('need WEBGL_depth_texture');
          }

          if (gl == null)
          {
            alert('Unable to initialize WebGL. Your browser or machine may not support it.');
            return false;
          }

          gl.clearColor(0.1, 0.1, 0.1, 1.0);
          gl.clearDepth(1.0);                 // Clear everything
          gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
          gl.enable(gl.DEPTH_TEST);           // Enable depth testing
          gl.getExtension('OES_element_index_uint');
          gl.enable(gl.BLEND);
          gl.enable(gl.CULL_FACE);
          gl.cullFace(gl.FRONT);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

          window.gl = gl;

          const vertex_shader = `
          attribute vec3 a_position;
          attribute vec2 a_tex_coord;
          varying lowp vec2 v_tex_coord;
          varying lowp vec3 v_pos;
          void main (void) {
            gl_Position = vec4(v_pos = a_position, 1.0);
            v_tex_coord = a_tex_coord;
          }`;

          const frag_shader = `
          varying lowp vec2 v_tex_coord;
          varying lowp vec3 v_pos;
          uniform lowp float u_progress;
          void main (void) {
            if (0.1 > v_pos.y && v_pos.y > -0.1 && v_pos.x < ((u_progress * 2.0) - 1.0))
            {
              gl_FragColor = vec4(1.0);
            }
            else
            {
              gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            }
          }`;

          g.web.gfx.shader.create('loading',
            vertex_shader,
            frag_shader
          );

              g.web.assets['mesh/plane'] = g.web.gfx.mesh.plane();

          if (document.body.onresize) { document.body.onresize(); }

          return true;
        }
      },
      helpers: {
        pixel_to_canonical: function(pixel_coord) {
          const tr = [].translate([
            (2 * pixel_coord[0] / g.web.gfx.width()) - 1,
            -(2 * pixel_coord[1] / g.web.gfx.height()) + 1,
            1,
          ]);//.mul(-1);
          return tr;
        }
      },
      width: function() { return g.web._canvas.width; },
      height: function() { return g.web._canvas.height; },
      aspect: function() { return g.web._canvas.width / g.web._canvas.height; },
      texture: {
        create: function(img)
        {
          const tex = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, tex);

          function is_power_of_2(n) { return (n != 0) && ((n & (n - 1))) == 0; }

          tex.width = img.width;
          tex.height = img.height;

          tex.depth = function() {
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              gl.DEPTH_COMPONENT,
              img.width,
              img.height,
              0,
              gl.DEPTH_COMPONENT,
              gl.UNSIGNED_SHORT,
              null
            );

            return tex;
          };

          tex.color = function() {
            if (img instanceof HTMLImageElement || img instanceof HTMLCanvasElement)
            {
              gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                img
              );
            }
            else
            {
              gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                img.width,
                img.height,
                0,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                null
              );
            }

            return tex;
          };

          tex.pixelated = function() {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            return tex;
          };

          tex.smooth = function() {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            return tex;
          };

          tex.clamped = function() {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return tex;
          };

          tex.repeating = function() {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            return tex;
          };

          if (!is_power_of_2(tex.width)) { return tex.clamped(); }

          return tex;
        }
      },
      text: {
        create: function(width, height, font)
        {
          var canvas = document.createElement('canvas');
          document.body.appendChild(canvas);
          canvas.width = width || canvas.width;
          canvas.height = height || canvas.height;
          canvas.hidden = true;
          var ctx = canvas.getContext('2d');

          var texture = g.web.gfx.texture.create(canvas).color().clamped().smooth();
          ctx.font = font || '50px Arial';
          ctx.textBaseline = 'top';
          ctx.imageSmoothingEnabled = false;

          texture.canvas = canvas;
          texture.text = function(str, color)
          {
            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = color || "#000000ff";
            ctx.fillText(str, 0, 0);

            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              gl.RGBA,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              canvas
            );

            return texture;
          };

          return texture;
        }
      },
      render_target: {
        create: function(img) {
          const fbo = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

          fbo.color = function(tex)
          {
            fbo.color_attachment = tex;
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
            return fbo;
          }

          fbo.depth = function(tex)
          {
            fbo.depth_attachment = tex;
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, tex, 0);
            return fbo;
          }

          fbo.shadow_map = function()
          {
            var depth_tex = g.web.gfx.texture.create(img).depth().clamped().smooth();
            return fbo.depth(depth_tex);
          }

          fbo.bind_as_target = ()=> {
            gl.viewport(0, 0, img.width, img.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
          };

          fbo.unbind_as_target = ()=> {
            if (fbo.color_attachment)
            {
              gl.generateMipmap(gl.TEXTURE_2D);
            }

            gl.viewport(0, 0, g.web.gfx.width(), g.web.gfx.height());
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          };

          return fbo;
        }
      },
      shader: {
        create: function(name, vertex_src, fragment_src)
        {
          function load_shader(type, source)
          {
            const shader = gl.createShader(type);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
            {
              console.error('Error building ' + type);
              console.error(source);
              console.error('An error occurred compiling the shader: ' + gl.getShaderInfoLog(shader));
              console.error('-------------------------');

              gl.deleteShader(shader);
              return null;
            }

            return shader;
          }

          const vertex_shader = load_shader(gl.VERTEX_SHADER, vertex_src);
          const fragment_shader = load_shader(gl.FRAGMENT_SHADER, fragment_src);

          const program = gl.createProgram();
          gl.attachShader(program, vertex_shader);
          gl.attachShader(program, fragment_shader);
          gl.linkProgram(program);

          if (!gl.getProgramParameter(program, gl.LINK_STATUS))
          {
            console.error('Failed to link shader program: ' + gl.getProgramInfoLog(program));
            return null;
          }

          return g.web.gfx.shader[name] = program;
        }
      },
      mesh: {
        create: function(mesh_json)
        {
          var mesh = {
            indices: null,
            vertices: {},
            shader_configs: {},
            element_count: 0,

            buffer: function(buffer_name)
            {
              const mesh_ref = this;

              return {
                set_data: function(v)
                {
                  let verts = v.as_Float32Array();
                  gl.bindBuffer(gl.ARRAY_BUFFER, mesh_ref.vertices[buffer_name]);
                  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.DYNAMIC_DRAW);
                  mesh_ref.element_count = verts.length;
                },
              };
            },

            using_shader: function(shader_name)
            {
              const mesh_ref = this;
              const shader = g.web.gfx.shader[shader_name];
              var tex_unit = 0;
              gl.useProgram(shader);

              return {
                with_attribute: function(description)
                {
                  // TODO: add functionality to cache vertex attr pointers
                  const buf = mesh_ref.vertices[description.buffer];

                  if (buf === undefined) { console.error('Cannot use undefined buffer'); return; }
                  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                  const loc = gl.getAttribLocation(shader, description.name);
                  if (loc < 0)
                  {
                    // console.error('Cannot find location for attribute "' + name + '" in shader "' + shader_name + '"');
                    return this;
                  }

                  gl.vertexAttribPointer(
                    loc,
                    description.components || 1,
                    description.type || gl.FLOAT,
                    description.normalized || false,
                    description.stride || 0,
                    description.offset || 0
                  );
                  gl.enableVertexAttribArray(loc);

                  return this;
                },
                with_camera: function(camera)
                {
                  return this.set_uniform('u_proj').mat4(camera.projection())
                         .set_uniform('u_view').mat4(camera.view());
                },
                with_aspect_correct_2d: function(tex, transform)
                {
                  transform = transform || [].I(4);
                  const scale = [].mat_scale([
                    2 * tex.width / g.web.gfx.width(),
                    2 * tex.height / g.web.gfx.height(),
                    1
                  ]);

                  transform = scale.mat_mul(transform);

                  return this.set_uniform('u_texture').texture(tex)
                             .set_uniform('u_proj').mat4([].I(4))
                             .set_uniform('u_view').mat4([].I(4))
                             .set_uniform('u_model').mat4(transform)
                },
                set_uniform: function(uni_name)
                {
                  const shader_ref = this;
                  const loc = gl.getUniformLocation(shader, uni_name);

                  // if (loc < 0) { console.error('Could not find uniform "' + uni_name + '"'); }

                  return {
                    mat4: function(m)
                    {
                      const v = m.as_Float32Array();
                      gl.uniformMatrix4fv(loc, false, v);
                      return shader_ref;
                    },
                    vec3: function(v)
                    {
                      gl.uniform3fv(loc, v.as_Float32Array());
                      return shader_ref;
                    },
                    vec4: function(v)
                    {
                      gl.uniform4fv(loc, v.as_Float32Array(), 1);
                      return shader_ref;
                    },
                    float: function(s)
                    {
                      gl.uniform1f(loc, s);
                      return shader_ref;
                    },
                    texture: function(tex)
                    {
                      gl.activeTexture(gl.TEXTURE0 + tex_unit);
                      gl.bindTexture(gl.TEXTURE_2D, tex);
                      gl.uniform1i(loc, tex_unit);
                      ++tex_unit;
                      return shader_ref;
                    },
                  };
                },
                draw_tris: function()
                {
                  if (mesh_ref.indices)
                  {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh_ref.indices);
                    gl.drawElements(
                      gl.TRIANGLES,
                      mesh_ref.element_count,
                      mesh_ref.index_type,
                      0
                    );
                  }
                  else
                  {
                    gl.drawArrays(gl.TRIANGLES, 0, mesh_ref.positions.length / 9);
                  }

                  return this;
                },
                draw_tri_strip: function()
                {
                  if (mesh_ref.indices)
                  {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh_ref.indices);
                    gl.drawElements(
                      gl.TRIANGLE_STRIP,
                      mesh_ref.element_count,
                      mesh_ref.index_type,
                      0
                    );
                  }
                  else
                  {
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, mesh_ref.element_count / 3);
                  }

                  return this;
                },
                draw_tri_fan: function()
                {
                  if (mesh_ref.indices)
                  {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh_ref.indices);
                    gl.drawElements(
                      gl.TRIANGLE_FAN,
                      mesh_ref.element_count,
                      mesh_ref.index_type,
                      0
                    );
                  }
                  else
                  {
                    gl.drawArrays(gl.TRIANGLE_FAN, 0, mesh_ref.element_count);
                  }

                  return this;
                },
                draw_lines: function()
                {
                  if (mesh_ref.indices)
                  {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh_ref.indices);
                    gl.drawElements(
                      gl.LINES,
                      mesh_ref.element_count,
                      mesh_ref.index_type,
                      0
                    );
                  }
                  else
                  {
                    gl.drawArrays(gl.LINES, 0, mesh_ref.element_count);
                  }

                  return this;
                },
                draw_line_strip: function()
                {
                  if (mesh_ref.indices)
                  {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh_ref.indices);
                    gl.drawElements(
                      gl.LINES,
                      mesh_ref.element_count,
                      mesh_ref.index_type,
                      0
                    );
                  }
                  else
                  {
                    gl.drawArrays(gl.LINE_STRIP, 0, mesh_ref.element_count / 3);
                  }

                  return this;
                },
                draw_points: function()
                {
                  if (mesh_ref.indices)
                  {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh_ref.indices);
                    gl.drawElements(
                      gl.POINTS,
                      mesh_ref.element_count,
                      mesh_ref.index_type,
                      0
                    );
                  }
                  else
                  {
                    gl.drawArrays(gl.POINTS, 0, mesh_ref.element_count);
                  }

                  return this;
                }
              };
            },
          };

          if (!mesh_json) { return mesh; }

          if (mesh_json.positions)
          {
            mesh.vertices.positions = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertices.positions);
            gl.bufferData(gl.ARRAY_BUFFER, mesh_json.positions.as_Float32Array(), gl.STATIC_DRAW);
          }

          if (mesh_json.texture_coords)
          {
            mesh.vertices.texture_coords = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertices.texture_coords);
            gl.bufferData(gl.ARRAY_BUFFER, mesh_json.texture_coords.as_Float32Array(), gl.STATIC_DRAW);
          }

          if (mesh_json.colors)
          {
            mesh.vertices.colors = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertices.colors);
            gl.bufferData(gl.ARRAY_BUFFER, mesh_json.colors.as_Float32Array(), gl.STATIC_DRAW);
          }

          if (mesh_json.normals)
          {
            mesh.vertices.normals = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertices.normals);
            gl.bufferData(gl.ARRAY_BUFFER, mesh_json.normals.as_Float32Array(), gl.STATIC_DRAW);
          }

          if (mesh_json.indices)
          {
            mesh.indices = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indices);
            if (mesh_json.indices.length > 0xffff)
            {
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh_json.indices.as_Int32Array(), gl.STATIC_DRAW);
              mesh.index_type = gl.UNSIGNED_INT;
            }
            else
            {
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh_json.indices.as_Int16Array(), gl.STATIC_DRAW);
              mesh.index_type = gl.UNSIGNED_SHORT;
            }

            mesh.element_count = mesh_json.indices.length;
          }
          else
          {
            mesh.element_count = mesh_json.positions.length;
          }

          return mesh;
        },
        plane: function()
        {
          return g.web.gfx.mesh.create({
            positions: [[-1, 1, 0], [1, 1, 0], [1, -1, 0], [-1, -1, 0]],
            normals: [[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]],
            texture_coords: [[1, 1], [0, 1], [0, 0], [1, 0]],
          });
        }
      },
      voxel: {
        create: function(voxel)
        {
          voxel.generate = function()
          {

            const vol = voxel.width * voxel.depth * voxel.height;
            this.mesh = {
              positions: [],
              normals: [],
              colors: [],
              texture_coords: [],
              indices: [],
              center_of_mass: [0, 0, 0],
            };
            var mesh = this.mesh;

            /*
                x -->

              z   3---2
              |   | / |
              v   |/  |
                0---1

              indices [ 0, 3, 2, 0, 2, 1 ]
            */
            var ii = 0;
            var cell_count = 0;
            for (var wi = 0; wi < voxel.width; ++wi)
            for (var hi = 0; hi < voxel.height; ++hi)
            for (var di = 0; di < voxel.depth; ++di)
            {
              function has_neighbor_w(delta)
              {
                delta = wi + delta;
                if (delta < 0 || delta >= voxel.width) { return false; }
                return voxel.cells[delta][hi][di] > 0;
              }

              function has_neighbor_h(delta)
              {
                delta = hi + delta;
                if (delta < 0 || delta >= voxel.height) { return false; }
                return voxel.cells[wi][delta][di] > 0;
              }

              function has_neighbor_d(delta)
              {
                delta = di + delta;
                if (delta < 0 || delta >= voxel.depth) { return false; }
                return voxel.cells[wi][hi][delta] > 0;
              }

              const cell = voxel.cells[wi][hi][di];
              if (cell > 0)
              {
                const cell_top = has_neighbor_h(1), cell_bottom = has_neighbor_h(-1);
                const cell_left = has_neighbor_w(-1), cell_right = has_neighbor_w(1);
                const cell_front = has_neighbor_d(1), cell_back = has_neighbor_d(-1);

                const s = voxel.scale;
                const x = wi * s, y = hi * s, z = di * s;
                if (!cell_bottom) mesh.positions.push(x + 0, y + 0, z + 0, x + s, y + 0, z + 0, x + s, y + 0, z + s, x + 0, y + 0, z + s); // bottom 00-03
                if (!cell_left)   mesh.positions.push(x + 0, y + 0, z + 0, x + 0, y + s, z + 0, x + 0, y + s, z + s, x + 0, y + 0, z + s); // left   04-07
                if (!cell_front)  mesh.positions.push(x + 0, y + 0, z + s, x + 0, y + s, z + s, x + s, y + s, z + s, x + s, y + 0, z + s); // front  08-12
                if (!cell_right)  mesh.positions.push(x + s, y + 0, z + 0, x + s, y + s, z + 0, x + s, y + s, z + s, x + s, y + 0, z + s); // right  13-17
                if (!cell_back)   mesh.positions.push(x + 0, y + 0, z + 0, x + 0, y + s, z + 0, x + s, y + s, z + 0, x + s, y + 0, z + 0); // back   18-22
                if (!cell_top)    mesh.positions.push(x + 0, y + s, z + 0, x + s, y + s, z + 0, x + s, y + s, z + s, x + 0, y + s, z + s); // top    23-27

                if (!cell_bottom) mesh.texture_coords.push( 0.00, 1.00,  1/6, 1.00,  1/6, 0.00, 0.00, 0.00 ); // bottom
                if (!cell_left)   mesh.texture_coords.push(  4/6, 0.00,  4/6, 1.00,  3/6, 1.00,  3/6, 0.00 ); // left
                if (!cell_front)  mesh.texture_coords.push(  5/6, 0.00,  5/6, 1.00,  4/6, 1.00,  4/6, 0.00 ); // front
                if (!cell_right)  mesh.texture_coords.push(  1/6, 0.00,  1/6, 1.00,  2/6, 1.00,  2/6, 0.00 ); // right
                if (!cell_back)   mesh.texture_coords.push(  2/6, 0.00,  2/6, 1.00,  3/6, 1.00,  3/6, 0.00 ); // back
                if (!cell_top)    mesh.texture_coords.push(  5/6, 0.00, 1.00, 0.00, 1.00, 1.00,  5/6, 1.00 ); // top

                if (voxel.palette)
                {
                  const color = voxel.palette[cell];
                  const r = color[0], g = color[1], b = color[2]
                  if (!cell_bottom) mesh.colors.push(r, g, b, r, g, b, r, g, b, r, g, b); // bottom
                  if (!cell_left)   mesh.colors.push(r, g, b, r, g, b, r, g, b, r, g, b); // left
                  if (!cell_front)  mesh.colors.push(r, g, b, r, g, b, r, g, b, r, g, b); // front
                  if (!cell_right)  mesh.colors.push(r, g, b, r, g, b, r, g, b, r, g, b); // right
                  if (!cell_back)   mesh.colors.push(r, g, b, r, g, b, r, g, b, r, g, b); // back
                  if (!cell_top)    mesh.colors.push(r, g, b, r, g, b, r, g, b, r, g, b); // top
                }

                if (!cell_bottom) mesh.normals.push( 0,-1, 0, 0,-1, 0, 0,-1, 0, 0,-1, 0 ); // bottom
                if (!cell_left)   mesh.normals.push(-1, 0, 0,-1, 0, 0,-1, 0, 0,-1, 0, 0 ); // left
                if (!cell_front)  mesh.normals.push( 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ); // front
                if (!cell_right)  mesh.normals.push( 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0 ); // right
                if (!cell_back)   mesh.normals.push( 0, 0,-1, 0, 0,-1, 0, 0,-1, 0, 0,-1 ); // back
                if (!cell_top)    mesh.normals.push( 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 ); // top

                if (!cell_bottom) { mesh.indices.push(ii + 2, ii + 3, ii + 0, ii + 1, ii + 2, ii + 0); ii += 4; }
                if (!cell_left)   { mesh.indices.push(ii + 0, ii + 3, ii + 2, ii + 0, ii + 2, ii + 1); ii += 4; }
                if (!cell_front)  { mesh.indices.push(ii + 0, ii + 3, ii + 2, ii + 0, ii + 2, ii + 1); ii += 4; }
                if (!cell_right)  { mesh.indices.push(ii + 2, ii + 3, ii + 0, ii + 1, ii + 2, ii + 0); ii += 4; }
                if (!cell_back)   { mesh.indices.push(ii + 2, ii + 3, ii + 0, ii + 1, ii + 2, ii + 0); ii += 4; }
                if (!cell_top)    { mesh.indices.push(ii + 0, ii + 3, ii + 2, ii + 0, ii + 2, ii + 1); ii += 4; }

                mesh.center_of_mass[0] += x;
                mesh.center_of_mass[1] += y;
                mesh.center_of_mass[2] += z;
                cell_count++;
              }
            }

            mesh.center_of_mass = mesh.center_of_mass.mul(1 / cell_count);

            for (var pi = 0; pi < mesh.positions.length; pi += 3)
            {
              mesh.positions[pi + 0] = mesh.positions[pi + 0] - mesh.center_of_mass[0];
              mesh.positions[pi + 1] = mesh.positions[pi + 1] - mesh.center_of_mass[1];
              mesh.positions[pi + 2] = mesh.positions[pi + 2] - mesh.center_of_mass[2];
            }
          };

          voxel.generate();
          var gl_mesh = g.web.gfx.mesh.create(voxel.mesh);

          for (var key in gl_mesh)
          {
            voxel[key] = gl_mesh[key];
          }

          return voxel;
        }
      },
      sprite: {
        create: function(aesprite_json)
        {
          const img_w = aesprite_json.meta.size.w;
          const img_h = aesprite_json.meta.size.h;
          var frames = [];
          var tags = {};
          var layers = {};
          var layer = '';

          for_each(aesprite_json.meta.frameTags, (frame_tag) => {
            tags[frame_tag.name] = [];
            switch (frame_tag.direction)
            {
              case 'forward':
                for (var i = frame_tag.from; i <= frame_tag.to; ++i)
                {
                  tags[frame_tag.name].push(i);
                }
                break;
              case 'pingpong':
                for (var i = frame_tag.from; i <= frame_tag.to; ++i)
                {
                  tags[frame_tag.name].push(i);
                }
                for (var i = frame_tag.to; i >= frame_tag.from; --i)
                {
                  tags[frame_tag.name].push(i);
                }
                break;
            }

            tag = tags[frame_tag.name];
          });

          for_each(aesprite_json.meta.layers, (layer) => {
            layers[layer.name] = [];
            layer = layer.name;

            for (var frame_title in aesprite_json.frames)
            {
              const frame_meta = aesprite_json.frames[frame_title];
              const frame = frame_meta.frame;

              if (frame_title.indexOf(layer) <= -1) continue;

              layers[layer].push({
                x: frame.x / img_w,
                y: frame.y / img_h,
                w: frame.w / img_w,
                h: frame.h / img_h,
                sec: frame_meta.duration / 1000
              });
            }
          });

          for_each(aesprite_json.frames, (frame_meta) => {
            const frame = frame_meta.frame;
            frames.push({
              x: frame.x / img_w,
              y: frame.y / img_h,
              w: frame.w / img_w,
              h: frame.h / img_h,
              sec: frame_meta.duration / 1000
            });
          });

          return function() {
            this.frame_idx = 0;
            this.frame_duration = frames[0].sec;
            this.paused = false;
            this.speed = 1;
            this.tag = tag;
            this.tags = tags;
            this.layers = layers;
            this.layer = layer;
            this.queue = [];

            this.current_frame = function()
            {
              if (Object.keys(layers).length > 0)
              {
                return layers[this.layer][this.tag[this.frame_idx]];
              }

              return frames[this.tag[this.frame_idx]];
            }

            this.pause = function(pause) { this.paused = pause; }

            this.tick = function(dt)
            {
              dt *= this.speed;

              if(!this.paused)
              while (dt > 0)
              {
                const prev_dur = this.frame_duration;
                this.frame_duration -= dt;

                if (this.frame_duration <= 0)
                {
                  this.frame_idx++;
                  if (this.frame_idx >= this.tag.length)
                  {
                    if (this.queue.length > 0)
                    {
                      this.tag = this.queue.pop();
                    }

                    this.frame_idx = 0;
                  }
                  this.frame_duration = this.current_frame().sec;
                }

                dt -= prev_dur;
              }
            };

            this.set = function(tag)
            {
              this.frame_idx = 0;
              this.tag = this.tags[tag];
            }

            this.origin = function()
            {
              return [ this.current_frame().x,  this.current_frame().y ];
            };

            this.size = function()
            {
              return [ this.current_frame().w,  this.current_frame().h ];
            };
          };
        }
      }
    },
    snd: {
      _initalize: function()
      {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        g.web._audio_ctx = new AudioContext();
      },
      listener:
      {
        from_camera: function(cam)
        {
          const f = cam.forward(), u = cam.up();
          const p = cam.position();
          g.web._audio_ctx.listener.setOrientation(f[0], f[1], f[2], u[0], u[1], u[2]);
          g.web._audio_ctx.listener.setPosition(p[0], p[1], p[2]);
        }
      }
    },
    assets: {
      processors: {},
      load: function(asset_arr, on_finish)
      {
        var req_frame = window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame;
        var count = asset_arr.length;
        var loaded = 0;

        function load_resource(path)
        {
          return fetch(path).then(function(res)
          {
            console.log('Loading: ' + path);
            const type = res.headers.get('content-type');
            const type_stem = type.split('/')[0];
            var bytes_to_read = parseInt(res.headers.get('content-length'));

            const fields = path.split('.');
            const processors = fields.slice(1);
            const name = fields[0];

            function process_asset(asset)
            {
              for (var i = 0; i < processors.length; i++)
              {
                const proc_name = processors[i];
                if (proc_name in g.web.assets.processors)
                try
                {
                  asset = g.web.assets.processors[proc_name](asset);
                }
                catch (error)
                {
                  console.error('Error: processing "{}" with "{}" failed - {}'.format([path, proc_name, error]));
                }
              }

              return asset;
            }

            switch (type_stem)
            {
              case 'image':
              {
                var img = new Image();
                img.src = res.url;
                g.web.assets[path] = img;
                console.log('Finished: ' + path);

                // create webgl texture automatically
                img.onload = function()
                {
                  img = process_asset(img);

                  const tex_name = name.replace('imgs', 'tex');

                  var tex = g.web.gfx.texture.create(img).color().smooth().repeating();

                  if (processors.indexOf('pixelated') >= 0) { tex = tex.pixelated(); }
                  if (processors.indexOf('smooth') >= 0) { tex = tex.smooth(); }
                  if (processors.indexOf('repeating') >= 0) { tex = tex.repeating(); }
                  if (processors.indexOf('clamped') >= 0) { tex = tex.clamped(); }
                  g.web.assets[tex_name] = tex;
                };
              } break;

              case 'audio':
              {
                const sound_name = name.replace('sounds', 'sound');

                g.web.assets[sound_name] = function (pos)
                {
                  var ctx = g.web._audio_ctx;
                  this.audio = new Audio(res.url);
                  this.track = ctx.createMediaElementSource(this.audio);
                  this.panner = ctx.createPanner();
                  this.gain_node = ctx.createGain();
                  this.gain_node.gain.value = 2;

                  if (processors.indexOf('looping') >= 0) { this.audio.loop = true; }

                  this.track.connect(this.gain_node).connect(this.panner).connect(ctx.destination);
                  this.panner.setPosition(pos[0], pos[1], pos[2]);
                  this.speed = function(speed)
                  {
                    if (this.audio.playbackRate == speed) { return; }
                    this.audio.playbackRate = speed;
                  }
                  this.is_playing = function() { return !this.audio.paused && !this.audio.ended; }
                  this.loop = function(loop) { this.audio.loop = loop; return this; }
                  this.position = function(pos) { this.panner.setPosition(pos[0], pos[1], pos[2]); return this; }
                  this.play = function()        { this.audio.play(); return this; }
                  this.pause = function()       { this.audio.pause(); return this; }
                  this.gain = function(g)       { this.gain_node.gain.value = g; return this; }
                }
                console.log('Finished: ' + path);
              } break;
            }

            // specific mime types
            switch (type)
            {
              case 'application/json':
              case 'application/json; charset=UTF-8':
              {
                g.web.assets[path] = '';
                return res.json().then(function (json) {

                  g.web.assets[path] = process_asset(json);

                  if (path.indexOf('meshes') > -1)
                  {
                    const mesh_name = path.replace('meshes', 'mesh').replace('.json', '');
                    g.web.assets[mesh_name] = g.web.gfx.mesh.create(g.web.assets[path]);
                  }
                  else if (path.indexOf('voxels') > -1)
                  {
                    const mesh_name = path.replace('voxels', 'voxel').replace('.json', '');
                    g.web.assets[mesh_name] = g.web.gfx.voxel.create(g.voxel.create(g.web.assets[path]));
                  }
                  else if (path.indexOf('animations') > -1)
                  {
                    const animation_name = path.replace('animations', 'animation').replace('.json', '');
                    g.web.assets[animation_name] = g.web.gfx.sprite.create(g.web.assets[path]);
                  }

                  console.log('Finished OK: ' + path);
                });
              } break;

              case 'text/plain':
              case 'application/octet-stream':
              {
                g.web.assets[path] = '';
                return res.body.getReader().read().then(function(res)
                {
                  console.log('Loading: ' + path + ' bytes remaining: ' + bytes_to_read);
                  g.web.assets[path] += (new TextDecoder()).decode(res.value);
                });
              } break;
            }
          });
        }

        var promises = [];
        // for (var i = 0; i < asset_arr.length; i++)
        // {
        //  promises.push(load_resource(asset_arr[i]));
        // }
        function load(idx)
        {
          if (idx >= asset_arr.length) { return this; }
          return load_resource(asset_arr[idx]).then(function(){
            //function draw()
            //req_frame(draw);
            // draw();
            loaded += 1;
            return load(idx + 1);
          })
        }

        var started = false;
        var ticker = setInterval(function(){
          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          g.web.assets['mesh/plane'].using_shader('loading')
                                    .with_attribute({name:'a_position', buffer: 'positions', components: 3})
                                    .with_attribute({name:'a_tex_coord', buffer: 'texture_coords', components: 2})
                                    .set_uniform('u_progress').float(loaded/count)
                                    .draw_tri_fan();
          if (!started)
          {
            started = true;
            load(0).then(function(){
              clearInterval(ticker);
              on_finish();
            });
          }
        }, 10);

        // Promise.all(promises).then(function(values)
        // {
        //     on_finish();
        // });
        // setTimeout(function(){
        // load(0).then(function(){ clearInterval(ticker); on_finish(); })
        // });
      },
    },

    pointer:
    {
      _last : [ 0, 0 ],

      on_move: function(on_move_func)
      {
        g.web._canvas.addEventListener("touchmove", function(e)
        {
          const t = e.touches[0];
          e.preventDefault();

          if (g.web.pointer._last)
          {
            t.movementX = t.clientX - g.web.pointer._last[0];
            t.movementY = t.clientY - g.web.pointer._last[1];
          }

          if (g.web._audio_ctx.state === 'suspended')
          {
            g.web._audio_ctx.resume();
          }

          on_move_func(t);
          g.web.pointer._last = [ t.clientX, t.clientY ];
        }, false);

        g.web._canvas.addEventListener("mousemove", function(e)
        {
          e.preventDefault();
          g.web.pointer._last = [ e.clientX, e.clientY ];

          if (g.web._audio_ctx.state === 'suspended')
          {
            g.web._audio_ctx.resume();
          }

          on_move_func(e);
        }, false);

        return this;
      },

      on_scroll: function(on_scoll_func)
      {
        g.web._canvas.addEventListener("scroll", function(e)
        {
          on_scoll_func(e);
        });
      },

      on_pointer_lock_change: function(on_pointer_lock_func)
      {
        if ("onpointerlockchange" in document)
        {
          document.addEventListener('pointerlockchange', function(e)
          {
            on_pointer_lock_func(e);
          }, false);
        }
        else if ("onmozpointerlockchange" in document)
        {
          document.addEventListener('mozpointerlockchange', function(e)
          {
            on_pointer_lock_func(e);
          }, false);
        }
      },

      cast_ray: function(view)
      {
        const s = [ g.web.gfx.width(), g.web.gfx.height() ];
        const h = s.mul(0.5);
        const p = g.web.pointer._last.sub(h).div(h);
        const d = [ p[0], p[1], 1, 1 ];

        const dp = view.mat_mul(d);

        // console.log(dp);
      },

      on_press: function(on_press_func)
      {
        g.web._canvas.ontouchstart = function(e)
        {
          const t = e.touches[0];
          g.web.pointer._last = [ t.clientX, t.clientY ];
          on_press_func(e);
        };

        g.web._canvas.onmousedown = function(e)
        {
          const t = e;
          g.web.pointer._last = [ t.clientX, t.clientY ];
          on_press_func(e);
        };
      },

      on_release: function(on_release_func)
      {
        g.web._canvas.ontouchend = g.web._canvas.ontouchcancel = g.web._canvas.onmouseup = function()
        {
          on_release_func();
        };
      }
    },

    key:
    {
      _initalized: false,
      _initalize: function()
      {
        if (g.web.key._initalized) { return; }

        document.onkeydown = function(key)
        {
          g.web.key._map[key.key.toLowerCase()] = true;

          for (var i = g.web.key._key_down_handlers.length; i--;)
          {
            g.web.key._key_down_handlers[i](key.key.toLowerCase());
          }
        };

        document.onkeyup = function(key)
        {
          g.web.key._map[key.key.toLowerCase()] = false;

          for (var i = g.web.key._key_up_handlers.length; i--;)
          {
            g.web.key._key_up_handlers[i](key.key.toLowerCase());
          }
        };

        g.web.key._initalized = true;
      },
      _map: {},
      _key_down_handlers: [],
      _key_up_handlers: [],
      is_pressed: function(key)
      {
        g.web.key._initalize();

        return g.web.key._map[key] || false;
      },
      is_down: function(cb) { g.web.key._initalize(); g.web.key._key_down_handlers.push(cb); },
      is_up: function(cb) { g.web.key._initalize(); g.web.key._key_up_handlers.push(cb); }
    },

    on_message: function(f) { g.web._on_message = f; return this; },

    on: function(event)
    {
      return { 'do': function(cb) { g.web._on_event[event] = cb; }}
    },

    signal: function(name, msg)
    {
      g.web._socket.emit(name, msg);
    },

    canvas: function(dom_element, opts)
    {
      opts = opts || {};
      g.web._canvas = dom_element;

      if (opts.fill)
      {
        document.body.onresize = function(e) {
          g.web._canvas.width = document.body.clientWidth;
          g.web._canvas.height = document.body.clientHeight;
          gl.viewport(0, 0, document.body.clientWidth, document.body.clientHeight);
        };
      }
      else if (!opts.fixed_size)
      {
        document.body.onresize = function(e) {
          g.web._canvas.width = g.web._canvas.clientWidth;
          g.web._canvas.height = g.web._canvas.clientHeight;
          gl.viewport(0, 0, g.web._canvas.clientWidth, g.web._canvas.clientHeight);
        };
      }

      g.web._canvas.requestPointerLock = g.web._canvas.requestPointerLock ||
                         g.web._canvas.mozRequestPointerLock ||
                         function(){};

      document.exitPointerLock = document.exitPointerLock ||
                     document.mozExitPointerLock ||
                     function(){};

      g.web._canvas.requestPointerLock();

      return this;
    },

    draw: function(f) { g.web._draw = f; return this; }

  };

</script>
<script type="text/javascript">
const SRC_SPRITE_VS = `
attribute vec3 a_position;
attribute vec2 a_tex_coord;

uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_proj;

varying lowp vec2 v_tex_coord;

void main (void)
{
  gl_Position = u_proj * u_view * u_model * vec4(a_position, 1.0);
  v_tex_coord = vec2(1.0) - a_tex_coord;
}
`;

const SRC_SPRITE_FS = `
uniform sampler2D u_sprite_sheet;
uniform lowp vec4 u_origin_size;

varying lowp vec2 v_tex_coord;

void main (void)
{
    lowp vec2 origin = u_origin_size.xy;
    lowp vec2 size = u_origin_size.zw;
    gl_FragColor = texture2D(u_sprite_sheet, v_tex_coord * size + origin);
}
`;
const WIN_SPRITE={ "frames": {
   "win (back) 0.aseprite": {
    "frame": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (back) 1.aseprite": {
    "frame": { "x": 64, "y": 0, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (back) 2.aseprite": {
    "frame": { "x": 128, "y": 0, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (back) 3.aseprite": {
    "frame": { "x": 192, "y": 0, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (back) 4.aseprite": {
    "frame": { "x": 256, "y": 0, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (back) 5.aseprite": {
    "frame": { "x": 320, "y": 0, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (back) 6.aseprite": {
    "frame": { "x": 384, "y": 0, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (back) 7.aseprite": {
    "frame": { "x": 448, "y": 0, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (body) 0.aseprite": {
    "frame": { "x": 0, "y": 64, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (body) 1.aseprite": {
    "frame": { "x": 64, "y": 64, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (body) 2.aseprite": {
    "frame": { "x": 128, "y": 64, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (body) 3.aseprite": {
    "frame": { "x": 192, "y": 64, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (body) 4.aseprite": {
    "frame": { "x": 256, "y": 64, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (body) 5.aseprite": {
    "frame": { "x": 320, "y": 64, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (body) 6.aseprite": {
    "frame": { "x": 384, "y": 64, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (body) 7.aseprite": {
    "frame": { "x": 448, "y": 64, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (front) 0.aseprite": {
    "frame": { "x": 0, "y": 128, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (front) 1.aseprite": {
    "frame": { "x": 64, "y": 128, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (front) 2.aseprite": {
    "frame": { "x": 128, "y": 128, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (front) 3.aseprite": {
    "frame": { "x": 192, "y": 128, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (front) 4.aseprite": {
    "frame": { "x": 256, "y": 128, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (front) 5.aseprite": {
    "frame": { "x": 320, "y": 128, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (front) 6.aseprite": {
    "frame": { "x": 384, "y": 128, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (front) 7.aseprite": {
    "frame": { "x": 448, "y": 128, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (head) 0.aseprite": {
    "frame": { "x": 0, "y": 192, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (head) 1.aseprite": {
    "frame": { "x": 64, "y": 192, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (head) 2.aseprite": {
    "frame": { "x": 128, "y": 192, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (head) 3.aseprite": {
    "frame": { "x": 192, "y": 192, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (head) 4.aseprite": {
    "frame": { "x": 256, "y": 192, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (head) 5.aseprite": {
    "frame": { "x": 320, "y": 192, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (head) 6.aseprite": {
    "frame": { "x": 384, "y": 192, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   },
   "win (head) 7.aseprite": {
    "frame": { "x": 448, "y": 192, "w": 64, "h": 64 },
    "rotated": false,
    "trimmed": false,
    "spriteSourceSize": { "x": 0, "y": 0, "w": 64, "h": 64 },
    "sourceSize": { "w": 64, "h": 64 },
    "duration": 50
   }
 },
 "meta": {
  "app": "http://www.aseprite.org/",
  "version": "1.2.25",
  "format": "RGBA8888",
  "size": { "w": 512, "h": 256 },
  "scale": "1",
  "frameTags": [
   { "name": "wag", "from": 0, "to": 6, "direction": "forward" },
   { "name": "hop", "from": 7, "to": 7, "direction": "forward" }
  ],
  "layers": [
   { "name": "back", "opacity": 255, "blendMode": "normal" },
   { "name": "body", "opacity": 255, "blendMode": "normal" },
   { "name": "front", "opacity": 255, "blendMode": "normal" },
   { "name": "head", "opacity": 255, "blendMode": "normal" }
  ],
  "slices": [
  ]
 }
}

</script>
<img id="cone" style="display:none;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAgCAYAAAAbifjMAAAAAXNSR0IArs4c6QAAAOZJREFUSIntlb0NwjAQhZ9RNoiUAqVBYhRPmjk8QjYIEg2iQMoMpoCDy/3YpqFAvMZR7O/l7p2lAN9QXlP29sInYOijOu8atMAAsGuBT+erW6VpwIESbBos85SPh72CvSA3Bss8bQ6REa2WidmCZeKpmoGUrMKtoBYeSc3Wy0GBz3vRWXCtb66Xgfwyl9VOXlMOfQydcd6FrcqKY6zBgAiRt1HLgULcGOQENwdlEKGnAACXWx0eh/ezMuCbTZXIFy1tUPmAMQXapFbkymHTgDQOD4ivllwDCXvh/itwfiyluyDH+AO6A5wTfQcstWWdAAAAAElFTkSuQmCC">
<img
id="win"
style="display: none;"
src=" data:image/png;base64,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"
texture-params="pixelated.clamped"
/>
</body>
</html>
